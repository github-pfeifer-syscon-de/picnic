/*
 * Generated by gdbus-codegen-glibmm 2.42.0. DO NOT EDIT.
 *
 * The license of this code is the same as for the source it was derived from.
 */

#include "thumbnail1_proxy.h"

void org::freedesktop::DBus::Properties::Get(
    const Glib::ustring & arg_interface_name,
    const Glib::ustring & arg_property_name,
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Glib::VariantContainerBase base;
    base = PropertiesTypeWrap::Get_pack(
        arg_interface_name,
        arg_property_name);

    m_proxy->call("Get", callback, cancellable, base);
}

void org::freedesktop::DBus::Properties::Get_finish(
    Glib::VariantBase &out_value,
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);

    GVariant *output;
    g_variant_get_child(wrapped.gobj(), 0, "v", &output);
    out_value = Glib::VariantBase(output);
}

void org::freedesktop::DBus::Properties::GetAll(
    const Glib::ustring & arg_interface_name,
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Glib::VariantContainerBase base;
    base = PropertiesTypeWrap::GetAll_pack(
        arg_interface_name);

    m_proxy->call("GetAll", callback, cancellable, base);
}

void org::freedesktop::DBus::Properties::GetAll_finish(
    std::map<Glib::ustring,Glib::VariantBase> &out_properties,
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);

    Glib::Variant<std::map<Glib::ustring,Glib::VariantBase>> out_properties_v;
    wrapped.get_child(out_properties_v, 0);
    out_properties = out_properties_v.get();
}

void org::freedesktop::DBus::Properties::Set_finish(
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);
}

void org::freedesktop::DBus::Properties::handle_signal(const Glib::ustring& sender_name,
    const Glib::ustring& signal_name,
    const Glib::VariantContainerBase& parameters)
{
    if (signal_name == "PropertiesChanged") {
        if (parameters.get_n_children() != 3) return;
        Glib::Variant<Glib::ustring> base_interface_name;
        parameters.get_child(base_interface_name, 0);
        Glib::ustring p_interface_name;
        p_interface_name = base_interface_name.get();

        if (parameters.get_n_children() != 3) return;
        Glib::Variant<std::map<Glib::ustring,Glib::VariantBase>> base_changed_properties;
        parameters.get_child(base_changed_properties, 1);
        std::map<Glib::ustring,Glib::VariantBase> p_changed_properties;
        p_changed_properties = base_changed_properties.get();

        if (parameters.get_n_children() != 3) return;
        Glib::Variant<std::vector<Glib::ustring>> base_invalidated_properties;
        parameters.get_child(base_invalidated_properties, 2);
        std::vector<Glib::ustring> p_invalidated_properties;
        p_invalidated_properties = base_invalidated_properties.get();

        PropertiesChanged_signal.emit((p_interface_name), (p_changed_properties), (p_invalidated_properties));
    }
}

void org::freedesktop::DBus::Properties::createForBus(
    Gio::DBus::BusType busType,
    Gio::DBus::ProxyFlags proxyFlags,
    const std::string &name,
    const std::string &objectPath,
    const Gio::SlotAsyncReady &slot,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Gio::DBus::Proxy::create_for_bus(busType,
        name,
        objectPath,
        "org.freedesktop.DBus.Properties",
        slot,
        cancellable,
        Glib::RefPtr<Gio::DBus::InterfaceInfo>(),
        proxyFlags);
}

Glib::RefPtr<org::freedesktop::DBus::Properties> org::freedesktop::DBus::Properties::createForBusFinish(Glib::RefPtr<Gio::AsyncResult> result)
{
    Glib::RefPtr<Gio::DBus::Proxy> proxy =
        Gio::DBus::Proxy::create_for_bus_finish(result);
    org::freedesktop::DBus::Properties *p =
        new org::freedesktop::DBus::Properties(proxy);
    return Glib::RefPtr<org::freedesktop::DBus::Properties>(p);
}void org::freedesktop::DBus::Introspectable::Introspect(
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Glib::VariantContainerBase base;

    m_proxy->call("Introspect", callback, cancellable, base);
}

void org::freedesktop::DBus::Introspectable::Introspect_finish(
    Glib::ustring &out_xml_data,
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);

    Glib::Variant<Glib::ustring> out_xml_data_v;
    wrapped.get_child(out_xml_data_v, 0);
    out_xml_data = out_xml_data_v.get();
}

void org::freedesktop::DBus::Introspectable::handle_signal(const Glib::ustring& sender_name,
    const Glib::ustring& signal_name,
    const Glib::VariantContainerBase& parameters)
{
}

void org::freedesktop::DBus::Introspectable::createForBus(
    Gio::DBus::BusType busType,
    Gio::DBus::ProxyFlags proxyFlags,
    const std::string &name,
    const std::string &objectPath,
    const Gio::SlotAsyncReady &slot,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Gio::DBus::Proxy::create_for_bus(busType,
        name,
        objectPath,
        "org.freedesktop.DBus.Introspectable",
        slot,
        cancellable,
        Glib::RefPtr<Gio::DBus::InterfaceInfo>(),
        proxyFlags);
}

Glib::RefPtr<org::freedesktop::DBus::Introspectable> org::freedesktop::DBus::Introspectable::createForBusFinish(Glib::RefPtr<Gio::AsyncResult> result)
{
    Glib::RefPtr<Gio::DBus::Proxy> proxy =
        Gio::DBus::Proxy::create_for_bus_finish(result);
    org::freedesktop::DBus::Introspectable *p =
        new org::freedesktop::DBus::Introspectable(proxy);
    return Glib::RefPtr<org::freedesktop::DBus::Introspectable>(p);
}void org::freedesktop::DBus::Peer::Ping(
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Glib::VariantContainerBase base;

    m_proxy->call("Ping", callback, cancellable, base);
}

void org::freedesktop::DBus::Peer::Ping_finish(
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);
}

void org::freedesktop::DBus::Peer::GetMachineId(
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Glib::VariantContainerBase base;

    m_proxy->call("GetMachineId", callback, cancellable, base);
}

void org::freedesktop::DBus::Peer::GetMachineId_finish(
    Glib::ustring &out_machine_uuid,
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);

    Glib::Variant<Glib::ustring> out_machine_uuid_v;
    wrapped.get_child(out_machine_uuid_v, 0);
    out_machine_uuid = out_machine_uuid_v.get();
}

void org::freedesktop::DBus::Peer::handle_signal(const Glib::ustring& sender_name,
    const Glib::ustring& signal_name,
    const Glib::VariantContainerBase& parameters)
{
}

void org::freedesktop::DBus::Peer::createForBus(
    Gio::DBus::BusType busType,
    Gio::DBus::ProxyFlags proxyFlags,
    const std::string &name,
    const std::string &objectPath,
    const Gio::SlotAsyncReady &slot,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Gio::DBus::Proxy::create_for_bus(busType,
        name,
        objectPath,
        "org.freedesktop.DBus.Peer",
        slot,
        cancellable,
        Glib::RefPtr<Gio::DBus::InterfaceInfo>(),
        proxyFlags);
}

Glib::RefPtr<org::freedesktop::DBus::Peer> org::freedesktop::DBus::Peer::createForBusFinish(Glib::RefPtr<Gio::AsyncResult> result)
{
    Glib::RefPtr<Gio::DBus::Proxy> proxy =
        Gio::DBus::Proxy::create_for_bus_finish(result);
    org::freedesktop::DBus::Peer *p =
        new org::freedesktop::DBus::Peer(proxy);
    return Glib::RefPtr<org::freedesktop::DBus::Peer>(p);
}void org::freedesktop::thumbnails::Thumbnailer1::Queue(
    const std::vector<Glib::ustring> & arg_uris,
    const std::vector<Glib::ustring> & arg_mime_types,
    const Glib::ustring & arg_flavor,
    const Glib::ustring & arg_scheduler,
    guint32 arg_handle_to_unqueue,
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Glib::VariantContainerBase base;
    base = Thumbnailer1TypeWrap::Queue_pack(
        arg_uris,
        arg_mime_types,
        arg_flavor,
        arg_scheduler,
        arg_handle_to_unqueue);

    m_proxy->call("Queue", callback, cancellable, base);
}

void org::freedesktop::thumbnails::Thumbnailer1::Queue_finish(
    guint32 &out_handle,
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);

    Glib::Variant<guint32> out_handle_v;
    wrapped.get_child(out_handle_v, 0);
    out_handle = out_handle_v.get();
}

void org::freedesktop::thumbnails::Thumbnailer1::Dequeue(
    guint32 arg_handle,
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Glib::VariantContainerBase base;
    base = Thumbnailer1TypeWrap::Dequeue_pack(
        arg_handle);

    m_proxy->call("Dequeue", callback, cancellable, base);
}

void org::freedesktop::thumbnails::Thumbnailer1::Dequeue_finish(
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);
}

void org::freedesktop::thumbnails::Thumbnailer1::GetSupported(
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Glib::VariantContainerBase base;

    m_proxy->call("GetSupported", callback, cancellable, base);
}

void org::freedesktop::thumbnails::Thumbnailer1::GetSupported_finish(
    std::vector<Glib::ustring> &out_uri_schemes,
    std::vector<Glib::ustring> &out_mime_types,
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);

    Glib::Variant<std::vector<Glib::ustring>> out_uri_schemes_v;
    wrapped.get_child(out_uri_schemes_v, 0);
    out_uri_schemes = out_uri_schemes_v.get();

    Glib::Variant<std::vector<Glib::ustring>> out_mime_types_v;
    wrapped.get_child(out_mime_types_v, 1);
    out_mime_types = out_mime_types_v.get();
}

void org::freedesktop::thumbnails::Thumbnailer1::GetSchedulers(
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Glib::VariantContainerBase base;

    m_proxy->call("GetSchedulers", callback, cancellable, base);
}

void org::freedesktop::thumbnails::Thumbnailer1::GetSchedulers_finish(
    std::vector<Glib::ustring> &out_schedulers,
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);

    Glib::Variant<std::vector<Glib::ustring>> out_schedulers_v;
    wrapped.get_child(out_schedulers_v, 0);
    out_schedulers = out_schedulers_v.get();
}

void org::freedesktop::thumbnails::Thumbnailer1::GetFlavors(
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Glib::VariantContainerBase base;

    m_proxy->call("GetFlavors", callback, cancellable, base);
}

void org::freedesktop::thumbnails::Thumbnailer1::GetFlavors_finish(
    std::vector<Glib::ustring> &out_flavors,
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);

    Glib::Variant<std::vector<Glib::ustring>> out_flavors_v;
    wrapped.get_child(out_flavors_v, 0);
    out_flavors = out_flavors_v.get();
}

void org::freedesktop::thumbnails::Thumbnailer1::handle_signal(const Glib::ustring& sender_name,
    const Glib::ustring& signal_name,
    const Glib::VariantContainerBase& parameters)
{
    if (signal_name == "Started") {
        if (parameters.get_n_children() != 1) return;
        Glib::Variant<guint32> base_handle;
        parameters.get_child(base_handle, 0);
        guint32 p_handle;
        p_handle = base_handle.get();

        Started_signal.emit((p_handle));
    }
    if (signal_name == "Finished") {
        if (parameters.get_n_children() != 1) return;
        Glib::Variant<guint32> base_handle;
        parameters.get_child(base_handle, 0);
        guint32 p_handle;
        p_handle = base_handle.get();

        Finished_signal.emit((p_handle));
    }
    if (signal_name == "Ready") {
        if (parameters.get_n_children() != 2) return;
        Glib::Variant<guint32> base_handle;
        parameters.get_child(base_handle, 0);
        guint32 p_handle;
        p_handle = base_handle.get();

        if (parameters.get_n_children() != 2) return;
        Glib::Variant<std::vector<Glib::ustring>> base_uris;
        parameters.get_child(base_uris, 1);
        std::vector<Glib::ustring> p_uris;
        p_uris = base_uris.get();

        Ready_signal.emit((p_handle), (p_uris));
    }
    if (signal_name == "Error") {
        if (parameters.get_n_children() != 4) return;
        Glib::Variant<guint32> base_handle;
        parameters.get_child(base_handle, 0);
        guint32 p_handle;
        p_handle = base_handle.get();

        if (parameters.get_n_children() != 4) return;
        Glib::Variant<std::vector<Glib::ustring>> base_failed_uris;
        parameters.get_child(base_failed_uris, 1);
        std::vector<Glib::ustring> p_failed_uris;
        p_failed_uris = base_failed_uris.get();

        if (parameters.get_n_children() != 4) return;
        Glib::Variant<gint32> base_error_code;
        parameters.get_child(base_error_code, 2);
        gint32 p_error_code;
        p_error_code = base_error_code.get();

        if (parameters.get_n_children() != 4) return;
        Glib::Variant<Glib::ustring> base_message;
        parameters.get_child(base_message, 3);
        Glib::ustring p_message;
        p_message = base_message.get();

        Error_signal.emit((p_handle), (p_failed_uris), (p_error_code), (p_message));
    }
}

void org::freedesktop::thumbnails::Thumbnailer1::createForBus(
    Gio::DBus::BusType busType,
    Gio::DBus::ProxyFlags proxyFlags,
    const std::string &name,
    const std::string &objectPath,
    const Gio::SlotAsyncReady &slot,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Gio::DBus::Proxy::create_for_bus(busType,
        name,
        objectPath,
        "org.freedesktop.thumbnails.Thumbnailer1",
        slot,
        cancellable,
        Glib::RefPtr<Gio::DBus::InterfaceInfo>(),
        proxyFlags);
}

Glib::RefPtr<org::freedesktop::thumbnails::Thumbnailer1> org::freedesktop::thumbnails::Thumbnailer1::createForBusFinish(Glib::RefPtr<Gio::AsyncResult> result)
{
    Glib::RefPtr<Gio::DBus::Proxy> proxy =
        Gio::DBus::Proxy::create_for_bus_finish(result);
    org::freedesktop::thumbnails::Thumbnailer1 *p =
        new org::freedesktop::thumbnails::Thumbnailer1(proxy);
    return Glib::RefPtr<org::freedesktop::thumbnails::Thumbnailer1>(p);
}
