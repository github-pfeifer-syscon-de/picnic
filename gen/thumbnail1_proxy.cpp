/*
 * Generated by gdbus-codegen-glibmm 2.42.0. DO NOT EDIT.
 *
 * The license of this code is the same as for the source it was derived from.
 */

#include "thumbnail1_proxy.h"

#include <utility>

template<class T>
inline T specialGetter(Glib::Variant<T> variant)
{
    return variant.get();
}

template<>
inline std::string specialGetter(Glib::Variant<std::string> variant)
{
    // String is not guaranteed to be null-terminated, so don't use ::get()
    gsize n_elem;
    gsize elem_size = sizeof(char);
    char* data = (char*)g_variant_get_fixed_array(variant.gobj(), &n_elem, elem_size);

    return std::string(data, n_elem);
}

void org::freedesktop::DBus::PropertiesProxy::Get(
    const Glib::ustring & arg_interface_name,
    const Glib::ustring & arg_property_name,
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;
    base = PropertiesTypeWrap::Get_pack(
        arg_interface_name,
        arg_property_name);

    m_proxy->call("Get", callback, cancellable, base, timeout_msec);
}

void org::freedesktop::DBus::PropertiesProxy::Get_finish(
    Glib::VariantBase &out_value,
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);

    GVariant *output;
    g_variant_get_child(wrapped.gobj(), 0, "v", &output);
    out_value = Glib::VariantBase(output);
}

Glib::VariantBase
org::freedesktop::DBus::PropertiesProxy::Get_sync(
    const Glib::ustring & arg_interface_name,
    const Glib::ustring & arg_property_name,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;
    base = PropertiesTypeWrap::Get_pack(
        arg_interface_name,
        arg_property_name);

    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_sync("Get", cancellable, base, timeout_msec);

    Glib::VariantBase out_value;
    GVariant *output;
    g_variant_get_child(wrapped.gobj(), 0, "v", &output);
    out_value = Glib::VariantBase(output);
    return out_value;
}

void org::freedesktop::DBus::PropertiesProxy::GetAll(
    const Glib::ustring & arg_interface_name,
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;
    base = PropertiesTypeWrap::GetAll_pack(
        arg_interface_name);

    m_proxy->call("GetAll", callback, cancellable, base, timeout_msec);
}

void org::freedesktop::DBus::PropertiesProxy::GetAll_finish(
    std::map<Glib::ustring,Glib::VariantBase> &out_properties,
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);

    Glib::Variant<std::map<Glib::ustring,Glib::VariantBase>> out_properties_v;
    wrapped.get_child(out_properties_v, 0);
    out_properties = out_properties_v.get();
}

std::map<Glib::ustring,Glib::VariantBase>
org::freedesktop::DBus::PropertiesProxy::GetAll_sync(
    const Glib::ustring & arg_interface_name,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;
    base = PropertiesTypeWrap::GetAll_pack(
        arg_interface_name);

    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_sync("GetAll", cancellable, base, timeout_msec);

    std::map<Glib::ustring,Glib::VariantBase> out_properties;
    Glib::Variant<std::map<Glib::ustring,Glib::VariantBase>> out_properties_v;
    wrapped.get_child(out_properties_v, 0);
    out_properties = out_properties_v.get();
    return out_properties;
}

void org::freedesktop::DBus::PropertiesProxy::Set(
    const Glib::ustring & arg_interface_name,
    const Glib::ustring & arg_property_name,
    const Glib::VariantBase & arg_value,
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;
    base = PropertiesTypeWrap::Set_pack(
        arg_interface_name,
        arg_property_name,
        arg_value);

    m_proxy->call("Set", callback, cancellable, base, timeout_msec);
}

void org::freedesktop::DBus::PropertiesProxy::Set_finish(
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);
}

void
org::freedesktop::DBus::PropertiesProxy::Set_sync(
    const Glib::ustring & arg_interface_name,
    const Glib::ustring & arg_property_name,
    const Glib::VariantBase & arg_value,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;
    base = PropertiesTypeWrap::Set_pack(
        arg_interface_name,
        arg_property_name,
        arg_value);

    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_sync("Set", cancellable, base, timeout_msec);

}

void org::freedesktop::DBus::PropertiesProxy::handle_signal(const Glib::ustring&/* sender_name */,
    const Glib::ustring& signal_name,
    const Glib::VariantContainerBase& parameters)
{
    static_cast<void>(signal_name); // maybe unused
    static_cast<void>(parameters); // maybe unused

    if (signal_name == "PropertiesChanged") {
        if (parameters.get_n_children() != 3) return;
        Glib::Variant<Glib::ustring> base_interface_name;
        parameters.get_child(base_interface_name, 0);
        Glib::ustring p_interface_name;
        p_interface_name = base_interface_name.get();

        if (parameters.get_n_children() != 3) return;
        Glib::Variant<std::map<Glib::ustring,Glib::VariantBase>> base_changed_properties;
        parameters.get_child(base_changed_properties, 1);
        std::map<Glib::ustring,Glib::VariantBase> p_changed_properties;
        p_changed_properties = base_changed_properties.get();

        if (parameters.get_n_children() != 3) return;
        Glib::Variant<std::vector<Glib::ustring>> base_invalidated_properties;
        parameters.get_child(base_invalidated_properties, 2);
        std::vector<Glib::ustring> p_invalidated_properties;
        p_invalidated_properties = base_invalidated_properties.get();

        PropertiesChanged_signal.emit((p_interface_name), (p_changed_properties), (p_invalidated_properties));
    }
}

void org::freedesktop::DBus::PropertiesProxy::handle_properties_changed(
    const Gio::DBus::Proxy::MapChangedProperties &changed_properties,
    const std::vector<Glib::ustring> &/* invalidated_properties */)
{
    static_cast<void>(changed_properties); // maybe unused

    // Only check changed_properties since value will already be cached. Glib can be setup to get
    // values of invalidated properties in which case property will be in changed_properties when
    // value is actually received. See Gio::DBus::ProxyFlags::PROXY_FLAGS_GET_INVALIDATED_PROPERTIES .

}

org::freedesktop::DBus::PropertiesProxy::PropertiesProxy(const Glib::RefPtr<Gio::DBus::Proxy> &proxy) : m_proxy(proxy)
{
    m_proxy->signal_signal().connect(sigc::mem_fun(this, &PropertiesProxy::handle_signal));
    m_proxy->signal_properties_changed().
        connect(sigc::mem_fun(this, &PropertiesProxy::handle_properties_changed));
}

void org::freedesktop::DBus::PropertiesProxy::createForBus(
    Gio::DBus::BusType busType,
    Gio::DBus::ProxyFlags proxyFlags,
    const std::string &name,
    const std::string &objectPath,
    const Gio::SlotAsyncReady &slot,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Gio::DBus::Proxy::create_for_bus(busType,
        name,
        objectPath,
        "org.freedesktop.DBus.Properties",
        slot,
        cancellable,
        Glib::RefPtr<Gio::DBus::InterfaceInfo>(),
        proxyFlags);
}

Glib::RefPtr<org::freedesktop::DBus::PropertiesProxy> org::freedesktop::DBus::PropertiesProxy::createForBusFinish(const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::RefPtr<Gio::DBus::Proxy> proxy =
        Gio::DBus::Proxy::create_for_bus_finish(result);
    org::freedesktop::DBus::PropertiesProxy *p =
        new org::freedesktop::DBus::PropertiesProxy(proxy);
    return Glib::RefPtr<org::freedesktop::DBus::PropertiesProxy>(p);
}

Glib::RefPtr<org::freedesktop::DBus::PropertiesProxy> org::freedesktop::DBus::PropertiesProxy::createForBus_sync(
    Gio::DBus::BusType busType,
    Gio::DBus::ProxyFlags proxyFlags,
    const std::string &name,
    const std::string &objectPath,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Glib::RefPtr<Gio::DBus::Proxy> proxy =
        Gio::DBus::Proxy::create_for_bus_sync(busType,
            name,
            objectPath,
            "org.freedesktop.DBus.Properties",
            cancellable,
            Glib::RefPtr<Gio::DBus::InterfaceInfo>(),
            proxyFlags);
    org::freedesktop::DBus::PropertiesProxy *p =
        new org::freedesktop::DBus::PropertiesProxy(proxy);
    return Glib::RefPtr<org::freedesktop::DBus::PropertiesProxy>(p);
}void org::freedesktop::DBus::IntrospectableProxy::Introspect(
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;

    m_proxy->call("Introspect", callback, cancellable, base, timeout_msec);
}

void org::freedesktop::DBus::IntrospectableProxy::Introspect_finish(
    Glib::ustring &out_xml_data,
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);

    Glib::Variant<Glib::ustring> out_xml_data_v;
    wrapped.get_child(out_xml_data_v, 0);
    out_xml_data = out_xml_data_v.get();
}

Glib::ustring
org::freedesktop::DBus::IntrospectableProxy::Introspect_sync(
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;

    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_sync("Introspect", cancellable, base, timeout_msec);

    Glib::ustring out_xml_data;
    Glib::Variant<Glib::ustring> out_xml_data_v;
    wrapped.get_child(out_xml_data_v, 0);
    out_xml_data = out_xml_data_v.get();
    return out_xml_data;
}

void org::freedesktop::DBus::IntrospectableProxy::handle_signal(const Glib::ustring&/* sender_name */,
    const Glib::ustring& signal_name,
    const Glib::VariantContainerBase& parameters)
{
    static_cast<void>(signal_name); // maybe unused
    static_cast<void>(parameters); // maybe unused

}

void org::freedesktop::DBus::IntrospectableProxy::handle_properties_changed(
    const Gio::DBus::Proxy::MapChangedProperties &changed_properties,
    const std::vector<Glib::ustring> &/* invalidated_properties */)
{
    static_cast<void>(changed_properties); // maybe unused

    // Only check changed_properties since value will already be cached. Glib can be setup to get
    // values of invalidated properties in which case property will be in changed_properties when
    // value is actually received. See Gio::DBus::ProxyFlags::PROXY_FLAGS_GET_INVALIDATED_PROPERTIES .

}

org::freedesktop::DBus::IntrospectableProxy::IntrospectableProxy(const Glib::RefPtr<Gio::DBus::Proxy> &proxy) : m_proxy(proxy)
{
    m_proxy->signal_signal().connect(sigc::mem_fun(this, &IntrospectableProxy::handle_signal));
    m_proxy->signal_properties_changed().
        connect(sigc::mem_fun(this, &IntrospectableProxy::handle_properties_changed));
}

void org::freedesktop::DBus::IntrospectableProxy::createForBus(
    Gio::DBus::BusType busType,
    Gio::DBus::ProxyFlags proxyFlags,
    const std::string &name,
    const std::string &objectPath,
    const Gio::SlotAsyncReady &slot,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Gio::DBus::Proxy::create_for_bus(busType,
        name,
        objectPath,
        "org.freedesktop.DBus.Introspectable",
        slot,
        cancellable,
        Glib::RefPtr<Gio::DBus::InterfaceInfo>(),
        proxyFlags);
}

Glib::RefPtr<org::freedesktop::DBus::IntrospectableProxy> org::freedesktop::DBus::IntrospectableProxy::createForBusFinish(const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::RefPtr<Gio::DBus::Proxy> proxy =
        Gio::DBus::Proxy::create_for_bus_finish(result);
    org::freedesktop::DBus::IntrospectableProxy *p =
        new org::freedesktop::DBus::IntrospectableProxy(proxy);
    return Glib::RefPtr<org::freedesktop::DBus::IntrospectableProxy>(p);
}

Glib::RefPtr<org::freedesktop::DBus::IntrospectableProxy> org::freedesktop::DBus::IntrospectableProxy::createForBus_sync(
    Gio::DBus::BusType busType,
    Gio::DBus::ProxyFlags proxyFlags,
    const std::string &name,
    const std::string &objectPath,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Glib::RefPtr<Gio::DBus::Proxy> proxy =
        Gio::DBus::Proxy::create_for_bus_sync(busType,
            name,
            objectPath,
            "org.freedesktop.DBus.Introspectable",
            cancellable,
            Glib::RefPtr<Gio::DBus::InterfaceInfo>(),
            proxyFlags);
    org::freedesktop::DBus::IntrospectableProxy *p =
        new org::freedesktop::DBus::IntrospectableProxy(proxy);
    return Glib::RefPtr<org::freedesktop::DBus::IntrospectableProxy>(p);
}void org::freedesktop::DBus::PeerProxy::Ping(
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;

    m_proxy->call("Ping", callback, cancellable, base, timeout_msec);
}

void org::freedesktop::DBus::PeerProxy::Ping_finish(
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);
}

void
org::freedesktop::DBus::PeerProxy::Ping_sync(
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;

    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_sync("Ping", cancellable, base, timeout_msec);

}

void org::freedesktop::DBus::PeerProxy::GetMachineId(
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;

    m_proxy->call("GetMachineId", callback, cancellable, base, timeout_msec);
}

void org::freedesktop::DBus::PeerProxy::GetMachineId_finish(
    Glib::ustring &out_machine_uuid,
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);

    Glib::Variant<Glib::ustring> out_machine_uuid_v;
    wrapped.get_child(out_machine_uuid_v, 0);
    out_machine_uuid = out_machine_uuid_v.get();
}

Glib::ustring
org::freedesktop::DBus::PeerProxy::GetMachineId_sync(
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;

    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_sync("GetMachineId", cancellable, base, timeout_msec);

    Glib::ustring out_machine_uuid;
    Glib::Variant<Glib::ustring> out_machine_uuid_v;
    wrapped.get_child(out_machine_uuid_v, 0);
    out_machine_uuid = out_machine_uuid_v.get();
    return out_machine_uuid;
}

void org::freedesktop::DBus::PeerProxy::handle_signal(const Glib::ustring&/* sender_name */,
    const Glib::ustring& signal_name,
    const Glib::VariantContainerBase& parameters)
{
    static_cast<void>(signal_name); // maybe unused
    static_cast<void>(parameters); // maybe unused

}

void org::freedesktop::DBus::PeerProxy::handle_properties_changed(
    const Gio::DBus::Proxy::MapChangedProperties &changed_properties,
    const std::vector<Glib::ustring> &/* invalidated_properties */)
{
    static_cast<void>(changed_properties); // maybe unused

    // Only check changed_properties since value will already be cached. Glib can be setup to get
    // values of invalidated properties in which case property will be in changed_properties when
    // value is actually received. See Gio::DBus::ProxyFlags::PROXY_FLAGS_GET_INVALIDATED_PROPERTIES .

}

org::freedesktop::DBus::PeerProxy::PeerProxy(const Glib::RefPtr<Gio::DBus::Proxy> &proxy) : m_proxy(proxy)
{
    m_proxy->signal_signal().connect(sigc::mem_fun(this, &PeerProxy::handle_signal));
    m_proxy->signal_properties_changed().
        connect(sigc::mem_fun(this, &PeerProxy::handle_properties_changed));
}

void org::freedesktop::DBus::PeerProxy::createForBus(
    Gio::DBus::BusType busType,
    Gio::DBus::ProxyFlags proxyFlags,
    const std::string &name,
    const std::string &objectPath,
    const Gio::SlotAsyncReady &slot,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Gio::DBus::Proxy::create_for_bus(busType,
        name,
        objectPath,
        "org.freedesktop.DBus.Peer",
        slot,
        cancellable,
        Glib::RefPtr<Gio::DBus::InterfaceInfo>(),
        proxyFlags);
}

Glib::RefPtr<org::freedesktop::DBus::PeerProxy> org::freedesktop::DBus::PeerProxy::createForBusFinish(const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::RefPtr<Gio::DBus::Proxy> proxy =
        Gio::DBus::Proxy::create_for_bus_finish(result);
    org::freedesktop::DBus::PeerProxy *p =
        new org::freedesktop::DBus::PeerProxy(proxy);
    return Glib::RefPtr<org::freedesktop::DBus::PeerProxy>(p);
}

Glib::RefPtr<org::freedesktop::DBus::PeerProxy> org::freedesktop::DBus::PeerProxy::createForBus_sync(
    Gio::DBus::BusType busType,
    Gio::DBus::ProxyFlags proxyFlags,
    const std::string &name,
    const std::string &objectPath,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Glib::RefPtr<Gio::DBus::Proxy> proxy =
        Gio::DBus::Proxy::create_for_bus_sync(busType,
            name,
            objectPath,
            "org.freedesktop.DBus.Peer",
            cancellable,
            Glib::RefPtr<Gio::DBus::InterfaceInfo>(),
            proxyFlags);
    org::freedesktop::DBus::PeerProxy *p =
        new org::freedesktop::DBus::PeerProxy(proxy);
    return Glib::RefPtr<org::freedesktop::DBus::PeerProxy>(p);
}void org::freedesktop::thumbnails::Thumbnailer1Proxy::Queue(
    const std::vector<Glib::ustring> & arg_uris,
    const std::vector<Glib::ustring> & arg_mime_types,
    const Glib::ustring & arg_flavor,
    const Glib::ustring & arg_scheduler,
    guint32 arg_handle_to_unqueue,
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;
    base = Thumbnailer1TypeWrap::Queue_pack(
        arg_uris,
        arg_mime_types,
        arg_flavor,
        arg_scheduler,
        arg_handle_to_unqueue);

    m_proxy->call("Queue", callback, cancellable, base, timeout_msec);
}

void org::freedesktop::thumbnails::Thumbnailer1Proxy::Queue_finish(
    guint32 &out_handle,
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);

    Glib::Variant<guint32> out_handle_v;
    wrapped.get_child(out_handle_v, 0);
    out_handle = out_handle_v.get();
}

guint32
org::freedesktop::thumbnails::Thumbnailer1Proxy::Queue_sync(
    const std::vector<Glib::ustring> & arg_uris,
    const std::vector<Glib::ustring> & arg_mime_types,
    const Glib::ustring & arg_flavor,
    const Glib::ustring & arg_scheduler,
    guint32 arg_handle_to_unqueue,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;
    base = Thumbnailer1TypeWrap::Queue_pack(
        arg_uris,
        arg_mime_types,
        arg_flavor,
        arg_scheduler,
        arg_handle_to_unqueue);

    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_sync("Queue", cancellable, base, timeout_msec);

    guint32 out_handle;
    Glib::Variant<guint32> out_handle_v;
    wrapped.get_child(out_handle_v, 0);
    out_handle = out_handle_v.get();
    return out_handle;
}

void org::freedesktop::thumbnails::Thumbnailer1Proxy::Dequeue(
    guint32 arg_handle,
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;
    base = Thumbnailer1TypeWrap::Dequeue_pack(
        arg_handle);

    m_proxy->call("Dequeue", callback, cancellable, base, timeout_msec);
}

void org::freedesktop::thumbnails::Thumbnailer1Proxy::Dequeue_finish(
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);
}

void
org::freedesktop::thumbnails::Thumbnailer1Proxy::Dequeue_sync(
    guint32 arg_handle,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;
    base = Thumbnailer1TypeWrap::Dequeue_pack(
        arg_handle);

    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_sync("Dequeue", cancellable, base, timeout_msec);

}

void org::freedesktop::thumbnails::Thumbnailer1Proxy::GetSupported(
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;

    m_proxy->call("GetSupported", callback, cancellable, base, timeout_msec);
}

void org::freedesktop::thumbnails::Thumbnailer1Proxy::GetSupported_finish(
    std::vector<Glib::ustring> &out_uri_schemes,
    std::vector<Glib::ustring> &out_mime_types,
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);

    Glib::Variant<std::vector<Glib::ustring>> out_uri_schemes_v;
    wrapped.get_child(out_uri_schemes_v, 0);
    out_uri_schemes = out_uri_schemes_v.get();

    Glib::Variant<std::vector<Glib::ustring>> out_mime_types_v;
    wrapped.get_child(out_mime_types_v, 1);
    out_mime_types = out_mime_types_v.get();
}

std::tuple<std::vector<Glib::ustring>, std::vector<Glib::ustring>>
org::freedesktop::thumbnails::Thumbnailer1Proxy::GetSupported_sync(
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;

    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_sync("GetSupported", cancellable, base, timeout_msec);

    std::vector<Glib::ustring> out_uri_schemes;
    Glib::Variant<std::vector<Glib::ustring>> out_uri_schemes_v;
    wrapped.get_child(out_uri_schemes_v, 0);
    out_uri_schemes = out_uri_schemes_v.get();

    std::vector<Glib::ustring> out_mime_types;
    Glib::Variant<std::vector<Glib::ustring>> out_mime_types_v;
    wrapped.get_child(out_mime_types_v, 1);
    out_mime_types = out_mime_types_v.get();

    return std::make_tuple(
        std::move(out_uri_schemes),
        std::move(out_mime_types)
    );
}

void org::freedesktop::thumbnails::Thumbnailer1Proxy::GetSchedulers(
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;

    m_proxy->call("GetSchedulers", callback, cancellable, base, timeout_msec);
}

void org::freedesktop::thumbnails::Thumbnailer1Proxy::GetSchedulers_finish(
    std::vector<Glib::ustring> &out_schedulers,
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);

    Glib::Variant<std::vector<Glib::ustring>> out_schedulers_v;
    wrapped.get_child(out_schedulers_v, 0);
    out_schedulers = out_schedulers_v.get();
}

std::vector<Glib::ustring>
org::freedesktop::thumbnails::Thumbnailer1Proxy::GetSchedulers_sync(
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;

    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_sync("GetSchedulers", cancellable, base, timeout_msec);

    std::vector<Glib::ustring> out_schedulers;
    Glib::Variant<std::vector<Glib::ustring>> out_schedulers_v;
    wrapped.get_child(out_schedulers_v, 0);
    out_schedulers = out_schedulers_v.get();
    return out_schedulers;
}

void org::freedesktop::thumbnails::Thumbnailer1Proxy::GetFlavors(
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;

    m_proxy->call("GetFlavors", callback, cancellable, base, timeout_msec);
}

void org::freedesktop::thumbnails::Thumbnailer1Proxy::GetFlavors_finish(
    std::vector<Glib::ustring> &out_flavors,
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);

    Glib::Variant<std::vector<Glib::ustring>> out_flavors_v;
    wrapped.get_child(out_flavors_v, 0);
    out_flavors = out_flavors_v.get();
}

std::vector<Glib::ustring>
org::freedesktop::thumbnails::Thumbnailer1Proxy::GetFlavors_sync(
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;

    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_sync("GetFlavors", cancellable, base, timeout_msec);

    std::vector<Glib::ustring> out_flavors;
    Glib::Variant<std::vector<Glib::ustring>> out_flavors_v;
    wrapped.get_child(out_flavors_v, 0);
    out_flavors = out_flavors_v.get();
    return out_flavors;
}

void org::freedesktop::thumbnails::Thumbnailer1Proxy::handle_signal(const Glib::ustring&/* sender_name */,
    const Glib::ustring& signal_name,
    const Glib::VariantContainerBase& parameters)
{
    static_cast<void>(signal_name); // maybe unused
    static_cast<void>(parameters); // maybe unused

    if (signal_name == "Started") {
        if (parameters.get_n_children() != 1) return;
        Glib::Variant<guint32> base_handle;
        parameters.get_child(base_handle, 0);
        guint32 p_handle;
        p_handle = base_handle.get();

        Started_signal.emit((p_handle));
    }
    if (signal_name == "Finished") {
        if (parameters.get_n_children() != 1) return;
        Glib::Variant<guint32> base_handle;
        parameters.get_child(base_handle, 0);
        guint32 p_handle;
        p_handle = base_handle.get();

        Finished_signal.emit((p_handle));
    }
    if (signal_name == "Ready") {
        if (parameters.get_n_children() != 2) return;
        Glib::Variant<guint32> base_handle;
        parameters.get_child(base_handle, 0);
        guint32 p_handle;
        p_handle = base_handle.get();

        if (parameters.get_n_children() != 2) return;
        Glib::Variant<std::vector<Glib::ustring>> base_uris;
        parameters.get_child(base_uris, 1);
        std::vector<Glib::ustring> p_uris;
        p_uris = base_uris.get();

        Ready_signal.emit((p_handle), (p_uris));
    }
    if (signal_name == "Error") {
        if (parameters.get_n_children() != 4) return;
        Glib::Variant<guint32> base_handle;
        parameters.get_child(base_handle, 0);
        guint32 p_handle;
        p_handle = base_handle.get();

        if (parameters.get_n_children() != 4) return;
        Glib::Variant<std::vector<Glib::ustring>> base_failed_uris;
        parameters.get_child(base_failed_uris, 1);
        std::vector<Glib::ustring> p_failed_uris;
        p_failed_uris = base_failed_uris.get();

        if (parameters.get_n_children() != 4) return;
        Glib::Variant<gint32> base_error_code;
        parameters.get_child(base_error_code, 2);
        gint32 p_error_code;
        p_error_code = base_error_code.get();

        if (parameters.get_n_children() != 4) return;
        Glib::Variant<Glib::ustring> base_message;
        parameters.get_child(base_message, 3);
        Glib::ustring p_message;
        p_message = base_message.get();

        Error_signal.emit((p_handle), (p_failed_uris), (p_error_code), (p_message));
    }
}

void org::freedesktop::thumbnails::Thumbnailer1Proxy::handle_properties_changed(
    const Gio::DBus::Proxy::MapChangedProperties &changed_properties,
    const std::vector<Glib::ustring> &/* invalidated_properties */)
{
    static_cast<void>(changed_properties); // maybe unused

    // Only check changed_properties since value will already be cached. Glib can be setup to get
    // values of invalidated properties in which case property will be in changed_properties when
    // value is actually received. See Gio::DBus::ProxyFlags::PROXY_FLAGS_GET_INVALIDATED_PROPERTIES .

}

org::freedesktop::thumbnails::Thumbnailer1Proxy::Thumbnailer1Proxy(const Glib::RefPtr<Gio::DBus::Proxy> &proxy) : m_proxy(proxy)
{
    m_proxy->signal_signal().connect(sigc::mem_fun(this, &Thumbnailer1Proxy::handle_signal));
    m_proxy->signal_properties_changed().
        connect(sigc::mem_fun(this, &Thumbnailer1Proxy::handle_properties_changed));
}

void org::freedesktop::thumbnails::Thumbnailer1Proxy::createForBus(
    Gio::DBus::BusType busType,
    Gio::DBus::ProxyFlags proxyFlags,
    const std::string &name,
    const std::string &objectPath,
    const Gio::SlotAsyncReady &slot,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Gio::DBus::Proxy::create_for_bus(busType,
        name,
        objectPath,
        "org.freedesktop.thumbnails.Thumbnailer1",
        slot,
        cancellable,
        Glib::RefPtr<Gio::DBus::InterfaceInfo>(),
        proxyFlags);
}

Glib::RefPtr<org::freedesktop::thumbnails::Thumbnailer1Proxy> org::freedesktop::thumbnails::Thumbnailer1Proxy::createForBusFinish(const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::RefPtr<Gio::DBus::Proxy> proxy =
        Gio::DBus::Proxy::create_for_bus_finish(result);
    org::freedesktop::thumbnails::Thumbnailer1Proxy *p =
        new org::freedesktop::thumbnails::Thumbnailer1Proxy(proxy);
    return Glib::RefPtr<org::freedesktop::thumbnails::Thumbnailer1Proxy>(p);
}

Glib::RefPtr<org::freedesktop::thumbnails::Thumbnailer1Proxy> org::freedesktop::thumbnails::Thumbnailer1Proxy::createForBus_sync(
    Gio::DBus::BusType busType,
    Gio::DBus::ProxyFlags proxyFlags,
    const std::string &name,
    const std::string &objectPath,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Glib::RefPtr<Gio::DBus::Proxy> proxy =
        Gio::DBus::Proxy::create_for_bus_sync(busType,
            name,
            objectPath,
            "org.freedesktop.thumbnails.Thumbnailer1",
            cancellable,
            Glib::RefPtr<Gio::DBus::InterfaceInfo>(),
            proxyFlags);
    org::freedesktop::thumbnails::Thumbnailer1Proxy *p =
        new org::freedesktop::thumbnails::Thumbnailer1Proxy(proxy);
    return Glib::RefPtr<org::freedesktop::thumbnails::Thumbnailer1Proxy>(p);
}
